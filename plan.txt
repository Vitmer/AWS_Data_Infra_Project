
Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_athena_workgroup.athena_workgroup will be created
  + resource "aws_athena_workgroup" "athena_workgroup" {
      + arn           = (known after apply)
      + force_destroy = false
      + id            = (known after apply)
      + name          = (known after apply)
      + state         = "ENABLED"
      + tags_all      = (known after apply)

      + configuration {
          + enforce_workgroup_configuration    = true
          + publish_cloudwatch_metrics_enabled = true
          + requester_pays_enabled             = false

          + result_configuration {
              + output_location = (known after apply)
            }
        }
    }

  # aws_autoscaling_group.example will be created
  + resource "aws_autoscaling_group" "example" {
      + arn                              = (known after apply)
      + availability_zones               = (known after apply)
      + default_cooldown                 = (known after apply)
      + desired_capacity                 = (known after apply)
      + force_delete                     = false
      + force_delete_warm_pool           = false
      + health_check_grace_period        = 300
      + health_check_type                = (known after apply)
      + id                               = (known after apply)
      + ignore_failed_scaling_activities = false
      + launch_configuration             = (known after apply)
      + load_balancers                   = (known after apply)
      + max_size                         = 5
      + metrics_granularity              = "1Minute"
      + min_size                         = 1
      + name                             = (known after apply)
      + name_prefix                      = (known after apply)
      + predicted_capacity               = (known after apply)
      + protect_from_scale_in            = false
      + service_linked_role_arn          = (known after apply)
      + target_group_arns                = (known after apply)
      + vpc_zone_identifier              = (known after apply)
      + wait_for_capacity_timeout        = "10m"
      + warm_pool_size                   = (known after apply)

      + availability_zone_distribution (known after apply)

      + launch_template (known after apply)

      + mixed_instances_policy (known after apply)

      + traffic_source (known after apply)
    }

  # aws_backup_plan.daily_backup will be created
  + resource "aws_backup_plan" "daily_backup" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + name     = "daily-backup-plan"
      + tags_all = (known after apply)
      + version  = (known after apply)

      + rule {
          + completion_window            = 180
          + enable_continuous_backup     = false
          + rule_name                    = "daily-backup-rule"
          + schedule                     = "cron(0 23 * * ? *)"
          + schedule_expression_timezone = "Etc/UTC"
          + start_window                 = 60
          + target_vault_name            = "ec2-backup-vault"

          + lifecycle {
              + delete_after                              = 30
              + opt_in_to_archive_for_supported_resources = (known after apply)
            }
        }
    }

  # aws_backup_plan.example will be created
  + resource "aws_backup_plan" "example" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + name     = "example-backup-plan"
      + tags_all = (known after apply)
      + version  = (known after apply)

      + rule {
          + completion_window            = 180
          + enable_continuous_backup     = false
          + rule_name                    = "example-rule"
          + schedule                     = "cron(0 12 * * ? *)"
          + schedule_expression_timezone = "Etc/UTC"
          + start_window                 = 60
          + target_vault_name            = "example-backup-vault"
        }
    }

  # aws_backup_selection.backup_selection will be created
  + resource "aws_backup_selection" "backup_selection" {
      + iam_role_arn  = (known after apply)
      + id            = (known after apply)
      + name          = "Backup-Selection"
      + not_resources = (known after apply)
      + plan_id       = (known after apply)
      + resources     = (known after apply)

      + condition (known after apply)
    }

  # aws_backup_vault.backup_vault will be created
  + resource "aws_backup_vault" "backup_vault" {
      + arn             = (known after apply)
      + force_destroy   = false
      + id              = (known after apply)
      + kms_key_arn     = (known after apply)
      + name            = "ec2-backup-vault"
      + recovery_points = (known after apply)
      + tags_all        = (known after apply)
    }

  # aws_backup_vault.example will be created
  + resource "aws_backup_vault" "example" {
      + arn             = (known after apply)
      + force_destroy   = false
      + id              = (known after apply)
      + kms_key_arn     = (known after apply)
      + name            = "example-backup-vault"
      + recovery_points = (known after apply)
      + tags_all        = (known after apply)
    }

  # aws_cloudtrail.example will be created
  + resource "aws_cloudtrail" "example" {
      + arn                           = (known after apply)
      + enable_log_file_validation    = false
      + enable_logging                = true
      + home_region                   = (known after apply)
      + id                            = (known after apply)
      + include_global_service_events = true
      + is_multi_region_trail         = true
      + is_organization_trail         = false
      + name                          = "example-cloudtrail"
      + s3_bucket_name                = "example-cloudtrail-bucket"
      + tags                          = {
          + "Name" = "example-cloudtrail"
        }
      + tags_all                      = {
          + "Name" = "example-cloudtrail"
        }

      + event_selector {
          + include_management_events = true
          + read_write_type           = "All"

          + data_resource {
              + type   = "AWS::S3::Object"
              + values = [
                  + "arn:aws:s3:::example-bucket/",
                ]
            }
        }
    }

  # aws_cloudwatch_log_group.example will be created
  + resource "aws_cloudwatch_log_group" "example" {
      + arn               = (known after apply)
      + id                = (known after apply)
      + log_group_class   = (known after apply)
      + name              = "/aws/example"
      + name_prefix       = (known after apply)
      + retention_in_days = 14
      + skip_destroy      = false
      + tags_all          = (known after apply)
    }

  # aws_cloudwatch_metric_alarm.example will be created
  + resource "aws_cloudwatch_metric_alarm" "example" {
      + actions_enabled                       = true
      + alarm_actions                         = (known after apply)
      + alarm_name                            = "ExampleAlarm"
      + arn                                   = (known after apply)
      + comparison_operator                   = "GreaterThanThreshold"
      + dimensions                            = {
          + "InstanceId" = "i-1234567890abcdef0"
        }
      + evaluate_low_sample_count_percentiles = (known after apply)
      + evaluation_periods                    = 1
      + id                                    = (known after apply)
      + insufficient_data_actions             = (known after apply)
      + metric_name                           = "CPUUtilization"
      + namespace                             = "AWS/EC2"
      + ok_actions                            = (known after apply)
      + period                                = 300
      + statistic                             = "Average"
      + tags                                  = {
          + "Name" = "example-metric-alarm"
        }
      + tags_all                              = {
          + "Name" = "example-metric-alarm"
        }
      + threshold                             = 80
      + treat_missing_data                    = "missing"
    }

  # aws_eip.example will be created
  + resource "aws_eip" "example" {
      + allocation_id        = (known after apply)
      + arn                  = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = "vpc"
      + id                   = (known after apply)
      + instance             = (known after apply)
      + ipam_pool_id         = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + ptr_record           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags_all             = (known after apply)
      + vpc                  = (known after apply)
    }

  # aws_eip.nat will be created
  + resource "aws_eip" "nat" {
      + allocation_id        = (known after apply)
      + arn                  = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = "vpc"
      + id                   = (known after apply)
      + instance             = (known after apply)
      + ipam_pool_id         = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + ptr_record           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags                 = {
          + "Name" = "NAT-Gateway-EIP"
        }
      + tags_all             = {
          + "Name" = "NAT-Gateway-EIP"
        }
      + vpc                  = (known after apply)
    }

  # aws_emr_cluster.databricks_emr will be created
  + resource "aws_emr_cluster" "databricks_emr" {
      + applications                      = [
          + "Hadoop",
          + "Spark",
        ]
      + arn                               = (known after apply)
      + cluster_state                     = (known after apply)
      + configurations_json               = jsonencode(
            [
              + {
                  + Classification = "spark"
                  + Properties     = {
                      + "spark.executor.cores"  = "2"
                      + "spark.executor.memory" = "2G"
                    }
                },
            ]
        )
      + id                                = (known after apply)
      + keep_job_flow_alive_when_no_steps = (known after apply)
      + master_public_dns                 = (known after apply)
      + name                              = (known after apply)
      + release_label                     = "emr-6.10.0"
      + scale_down_behavior               = (known after apply)
      + service_role                      = (known after apply)
      + step                              = (known after apply)
      + step_concurrency_level            = 1
      + tags_all                          = (known after apply)
      + termination_protection            = (known after apply)
      + unhealthy_node_replacement        = false
      + visible_to_all_users              = true

      + bootstrap_action {
          + name = "Install dependencies"
          + path = (known after apply)
        }

      + core_instance_fleet (known after apply)

      + core_instance_group {
          + id             = (known after apply)
          + instance_count = 2
          + instance_type  = "m5.xlarge"

          + ebs_config (known after apply)
        }

      + ec2_attributes {
          + emr_managed_master_security_group = (known after apply)
          + emr_managed_slave_security_group  = (known after apply)
          + instance_profile                  = (known after apply)
          + key_name                          = "Vitalij"
          + service_access_security_group     = (known after apply)
          + subnet_id                         = (known after apply)
          + subnet_ids                        = (known after apply)
        }

      + master_instance_fleet (known after apply)

      + master_instance_group {
          + id             = (known after apply)
          + instance_count = 1
          + instance_type  = "m5.xlarge"

          + ebs_config (known after apply)
        }
    }

  # aws_emr_cluster.example will be created
  + resource "aws_emr_cluster" "example" {
      + arn                               = (known after apply)
      + cluster_state                     = (known after apply)
      + id                                = (known after apply)
      + keep_job_flow_alive_when_no_steps = (known after apply)
      + master_public_dns                 = (known after apply)
      + name                              = "example-emr-cluster"
      + release_label                     = "emr-6.3.0"
      + scale_down_behavior               = (known after apply)
      + service_role                      = (known after apply)
      + step                              = (known after apply)
      + step_concurrency_level            = 1
      + tags_all                          = (known after apply)
      + termination_protection            = (known after apply)
      + unhealthy_node_replacement        = false
      + visible_to_all_users              = true

      + core_instance_fleet (known after apply)

      + core_instance_group {
          + id             = (known after apply)
          + instance_count = 2
          + instance_type  = "m5.xlarge"

          + ebs_config (known after apply)
        }

      + master_instance_fleet (known after apply)

      + master_instance_group {
          + id             = (known after apply)
          + instance_count = 1
          + instance_type  = "m5.xlarge"

          + ebs_config (known after apply)
        }
    }

  # aws_glue_catalog_database.example will be created
  + resource "aws_glue_catalog_database" "example" {
      + arn          = (known after apply)
      + catalog_id   = (known after apply)
      + id           = (known after apply)
      + location_uri = (known after apply)
      + name         = (known after apply)
      + tags_all     = (known after apply)

      + create_table_default_permission (known after apply)
    }

  # aws_glue_catalog_database.glue_database will be created
  + resource "aws_glue_catalog_database" "glue_database" {
      + arn          = (known after apply)
      + catalog_id   = (known after apply)
      + id           = (known after apply)
      + location_uri = (known after apply)
      + name         = (known after apply)
      + tags_all     = (known after apply)

      + create_table_default_permission (known after apply)
    }

  # aws_glue_catalog_table.analytics_table will be created
  + resource "aws_glue_catalog_table" "analytics_table" {
      + arn           = (known after apply)
      + catalog_id    = (known after apply)
      + database_name = (known after apply)
      + id            = (known after apply)
      + name          = "analytics_table"
      + parameters    = {
          + "EXTERNAL" = "TRUE"
        }
      + table_type    = "EXTERNAL_TABLE"

      + partition_index (known after apply)

      + storage_descriptor {
          + input_format  = "org.apache.hadoop.mapred.TextInputFormat"
          + location      = (known after apply)
          + output_format = "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat"

          + columns (known after apply)

          + ser_de_info {
              + serialization_library = "org.apache.hadoop.hive.serde2.OpenCSVSerde"
            }
        }
    }

  # aws_glue_catalog_table.blob_dataset will be created
  + resource "aws_glue_catalog_table" "blob_dataset" {
      + arn           = (known after apply)
      + catalog_id    = (known after apply)
      + database_name = (known after apply)
      + id            = (known after apply)
      + name          = "blob-dataset"
      + table_type    = "EXTERNAL_TABLE"

      + partition_index (known after apply)

      + storage_descriptor {
          + input_format  = "org.apache.hadoop.mapred.TextInputFormat"
          + location      = (known after apply)
          + output_format = "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat"

          + columns (known after apply)

          + ser_de_info {
              + serialization_library = "org.apache.hadoop.hive.serde2.OpenCSVSerde"
            }
        }
    }

  # aws_glue_catalog_table.redshift_dataset will be created
  + resource "aws_glue_catalog_table" "redshift_dataset" {
      + arn           = (known after apply)
      + catalog_id    = (known after apply)
      + database_name = (known after apply)
      + id            = (known after apply)
      + name          = "redshift-dataset"
      + table_type    = "EXTERNAL_TABLE"

      + partition_index (known after apply)

      + storage_descriptor {
          + input_format  = "org.apache.hadoop.mapred.TextInputFormat"
          + location      = (known after apply)
          + output_format = "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat"

          + columns (known after apply)

          + ser_de_info {
              + serialization_library = "org.apache.hadoop.hive.serde2.OpenCSVSerde"
            }
        }
    }

  # aws_glue_connection.redshift_connection will be created
  + resource "aws_glue_connection" "redshift_connection" {
      + arn                   = (known after apply)
      + catalog_id            = (known after apply)
      + connection_properties = (sensitive value)
      + connection_type       = "JDBC"
      + id                    = (known after apply)
      + name                  = (known after apply)
      + tags_all              = (known after apply)
    }

  # aws_glue_job.copy_blob_to_data_lake will be created
  + resource "aws_glue_job" "copy_blob_to_data_lake" {
      + arn               = (known after apply)
      + default_arguments = (known after apply)
      + glue_version      = (known after apply)
      + id                = (known after apply)
      + max_capacity      = 2
      + name              = "copy-blob-to-data-lake"
      + number_of_workers = (known after apply)
      + role_arn          = (known after apply)
      + tags_all          = (known after apply)
      + timeout           = (known after apply)
      + worker_type       = (known after apply)

      + command {
          + name            = "glueetl"
          + python_version  = "3"
          + runtime         = (known after apply)
          + script_location = (known after apply)
        }

      + execution_property (known after apply)

      + notification_property (known after apply)
    }

  # aws_glue_job.example will be created
  + resource "aws_glue_job" "example" {
      + arn               = (known after apply)
      + glue_version      = (known after apply)
      + id                = (known after apply)
      + max_capacity      = (known after apply)
      + name              = "example-glue-job"
      + number_of_workers = (known after apply)
      + role_arn          = (known after apply)
      + tags_all          = (known after apply)
      + timeout           = (known after apply)
      + worker_type       = (known after apply)

      + command {
          + name            = "glueetl"
          + python_version  = "3"
          + runtime         = (known after apply)
          + script_location = "s3://path-to-script/script.py"
        }

      + execution_property (known after apply)

      + notification_property (known after apply)
    }

  # aws_glue_trigger.etl_trigger will be created
  + resource "aws_glue_trigger" "etl_trigger" {
      + arn           = (known after apply)
      + enabled       = true
      + id            = (known after apply)
      + name          = (known after apply)
      + state         = (known after apply)
      + tags_all      = (known after apply)
      + type          = "ON_DEMAND"
      + workflow_name = (known after apply)

      + actions {
          + job_name = "copy-blob-to-data-lake"
        }
    }

  # aws_glue_workflow.etl_pipeline will be created
  + resource "aws_glue_workflow" "etl_pipeline" {
      + arn         = (known after apply)
      + description = "ETL pipeline using AWS Glue"
      + id          = (known after apply)
      + name        = (known after apply)
      + tags_all    = (known after apply)
    }

  # aws_iam_instance_profile.emr_profile will be created
  + resource "aws_iam_instance_profile" "emr_profile" {
      + arn         = (known after apply)
      + create_date = (known after apply)
      + id          = (known after apply)
      + name        = (known after apply)
      + name_prefix = (known after apply)
      + path        = "/"
      + role        = (known after apply)
      + tags_all    = (known after apply)
      + unique_id   = (known after apply)
    }

  # aws_iam_policy.s3_policy will be created
  + resource "aws_iam_policy" "s3_policy" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + id               = (known after apply)
      + name             = "s3-access-policy"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = (known after apply)
      + policy_id        = (known after apply)
      + tags_all         = (known after apply)
    }

  # aws_iam_policy.terraform_access will be created
  + resource "aws_iam_policy" "terraform_access" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + description      = "Policy for Terraform to manage secrets in Secrets Manager"
      + id               = (known after apply)
      + name             = "terraform-key-access"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = (known after apply)
      + policy_id        = (known after apply)
      + tags_all         = (known after apply)
    }

  # aws_iam_role.backup_role will be created
  + resource "aws_iam_role" "backup_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "backup.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "BackupRole"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.emr_service will be created
  + resource "aws_iam_role" "emr_service" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "elasticmapreduce.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "emr-service-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.emr_service_role will be created
  + resource "aws_iam_role" "emr_service_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "elasticmapreduce.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = (known after apply)
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.example will be created
  + resource "aws_iam_role" "example" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "lambda.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "example-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.example_emr will be created
  + resource "aws_iam_role" "example_emr" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "elasticmapreduce.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "example-emr-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.glue_service_role will be created
  + resource "aws_iam_role" "glue_service_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "glue.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = (known after apply)
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.kinesis_exec will be created
  + resource "aws_iam_role" "kinesis_exec" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "kinesisanalytics.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "kinesis-exec-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.lambda_exec will be created
  + resource "aws_iam_role" "lambda_exec" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "lambda.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "lambda-exec-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.redshift_role will be created
  + resource "aws_iam_role" "redshift_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "redshift.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = (known after apply)
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role_policy_attachment.backup_attach will be created
  + resource "aws_iam_role_policy_attachment" "backup_attach" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForBackup"
      + role       = "BackupRole"
    }

  # aws_iam_role_policy_attachment.emr_service_policy will be created
  + resource "aws_iam_role_policy_attachment" "emr_service_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonElasticMapReduceRole"
      + role       = (known after apply)
    }

  # aws_iam_role_policy_attachment.glue_policy will be created
  + resource "aws_iam_role_policy_attachment" "glue_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/service-role/AWSGlueServiceRole"
      + role       = (known after apply)
    }

  # aws_iam_role_policy_attachment.redshift_s3_access will be created
  + resource "aws_iam_role_policy_attachment" "redshift_s3_access" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess"
      + role       = (known after apply)
    }

  # aws_instance.bastion_private will be created
  + resource "aws_instance" "bastion_private" {
      + ami                                  = "ami-01a0731204136ddad"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + enable_primary_ipv6                  = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_lifecycle                   = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t2.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = "Vitalij"
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + spot_instance_request_id             = (known after apply)
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "Bastion-Private-Host"
        }
      + tags_all                             = {
          + "Name" = "Bastion-Private-Host"
        }
      + tenancy                              = (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + instance_market_options (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

  # aws_instance.bastion_public will be created
  + resource "aws_instance" "bastion_public" {
      + ami                                  = "ami-01a0731204136ddad"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + enable_primary_ipv6                  = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_lifecycle                   = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t2.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = "Vitalij"
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + spot_instance_request_id             = (known after apply)
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "Bastion-Public-Host"
        }
      + tags_all                             = {
          + "Name" = "Bastion-Public-Host"
        }
      + tenancy                              = (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + instance_market_options (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

  # aws_internet_gateway.main will be created
  + resource "aws_internet_gateway" "main" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name" = "Main-Internet-Gateway"
        }
      + tags_all = {
          + "Name" = "Main-Internet-Gateway"
        }
      + vpc_id   = (known after apply)
    }

  # aws_kinesis_stream.example will be created
  + resource "aws_kinesis_stream" "example" {
      + arn                       = (known after apply)
      + encryption_type           = "NONE"
      + enforce_consumer_deletion = false
      + id                        = (known after apply)
      + name                      = "example-stream"
      + retention_period          = 24
      + shard_count               = 1
      + tags_all                  = (known after apply)

      + stream_mode_details (known after apply)
    }

  # aws_kinesisanalyticsv2_application.example will be created
  + resource "aws_kinesisanalyticsv2_application" "example" {
      + application_mode       = (known after apply)
      + arn                    = (known after apply)
      + create_timestamp       = (known after apply)
      + id                     = (known after apply)
      + last_update_timestamp  = (known after apply)
      + name                   = "example-kinesis-app"
      + runtime_environment    = "SQL-1_0"
      + service_execution_role = (known after apply)
      + status                 = (known after apply)
      + tags_all               = (known after apply)
      + version_id             = (known after apply)

      + application_configuration {
          + application_code_configuration {
              + code_content_type = "PLAINTEXT"

              + code_content {
                  + text_content = <<-EOT
                        CREATE OR REPLACE STREAM "DESTINATION_SQL_STREAM" (
                          id VARCHAR(16),
                          value DOUBLE,
                          timestamp TIMESTAMP
                        );
                    EOT
                }
            }
          + application_snapshot_configuration (known after apply)
          + flink_application_configuration (known after apply)
          + run_configuration (known after apply)
        }
    }

  # aws_kms_alias.key_alias will be created
  + resource "aws_kms_alias" "key_alias" {
      + arn            = (known after apply)
      + id             = (known after apply)
      + name           = (known after apply)
      + name_prefix    = (known after apply)
      + target_key_arn = (known after apply)
      + target_key_id  = (known after apply)
    }

  # aws_kms_key.example will be created
  + resource "aws_kms_key" "example" {
      + arn                                = (known after apply)
      + bypass_policy_lockout_safety_check = false
      + customer_master_key_spec           = "SYMMETRIC_DEFAULT"
      + deletion_window_in_days            = 10
      + description                        = "Example key"
      + enable_key_rotation                = false
      + id                                 = (known after apply)
      + is_enabled                         = true
      + key_id                             = (known after apply)
      + key_usage                          = "ENCRYPT_DECRYPT"
      + multi_region                       = (known after apply)
      + policy                             = (known after apply)
      + rotation_period_in_days            = (known after apply)
      + tags_all                           = (known after apply)
    }

  # aws_kms_key.key will be created
  + resource "aws_kms_key" "key" {
      + arn                                = (known after apply)
      + bypass_policy_lockout_safety_check = false
      + customer_master_key_spec           = "SYMMETRIC_DEFAULT"
      + deletion_window_in_days            = 7
      + description                        = "KMS key for managing secrets"
      + enable_key_rotation                = false
      + id                                 = (known after apply)
      + is_enabled                         = true
      + key_id                             = (known after apply)
      + key_usage                          = "ENCRYPT_DECRYPT"
      + multi_region                       = (known after apply)
      + policy                             = (known after apply)
      + rotation_period_in_days            = (known after apply)
      + tags                               = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + tags_all                           = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
    }

  # aws_lambda_function.etl_processor will be created
  + resource "aws_lambda_function" "etl_processor" {
      + architectures                  = (known after apply)
      + arn                            = (known after apply)
      + code_sha256                    = (known after apply)
      + filename                       = "etl_processor.zip"
      + function_name                  = "etl-processor"
      + handler                        = "index.handler"
      + id                             = (known after apply)
      + invoke_arn                     = (known after apply)
      + last_modified                  = (known after apply)
      + memory_size                    = 128
      + package_type                   = "Zip"
      + publish                        = false
      + qualified_arn                  = (known after apply)
      + qualified_invoke_arn           = (known after apply)
      + reserved_concurrent_executions = -1
      + role                           = (known after apply)
      + runtime                        = "python3.9"
      + signing_job_arn                = (known after apply)
      + signing_profile_version_arn    = (known after apply)
      + skip_destroy                   = false
      + source_code_hash               = "2J7WR+n7H29DS28g3aRGFq/vgkPvl9Pp9Ys8GrkBMK8="
      + source_code_size               = (known after apply)
      + tags_all                       = (known after apply)
      + timeout                        = 3
      + version                        = (known after apply)

      + ephemeral_storage (known after apply)

      + logging_config (known after apply)

      + tracing_config (known after apply)
    }

  # aws_launch_configuration.example will be created
  + resource "aws_launch_configuration" "example" {
      + arn                         = (known after apply)
      + associate_public_ip_address = (known after apply)
      + ebs_optimized               = (known after apply)
      + enable_monitoring           = true
      + id                          = (known after apply)
      + image_id                    = "ami-12345678"
      + instance_type               = "t2.micro"
      + key_name                    = (known after apply)
      + name                        = "example-launch-configuration"
      + name_prefix                 = (known after apply)

      + ebs_block_device (known after apply)

      + metadata_options (known after apply)

      + root_block_device (known after apply)
    }

  # aws_nat_gateway.example will be created
  + resource "aws_nat_gateway" "example" {
      + allocation_id                      = (known after apply)
      + association_id                     = (known after apply)
      + connectivity_type                  = "public"
      + id                                 = (known after apply)
      + network_interface_id               = (known after apply)
      + private_ip                         = (known after apply)
      + public_ip                          = (known after apply)
      + secondary_private_ip_address_count = (known after apply)
      + secondary_private_ip_addresses     = (known after apply)
      + subnet_id                          = (known after apply)
      + tags                               = {
          + "Name" = "example-nat-gateway"
        }
      + tags_all                           = {
          + "Name" = "example-nat-gateway"
        }
    }

  # aws_nat_gateway.main will be created
  + resource "aws_nat_gateway" "main" {
      + allocation_id                      = (known after apply)
      + association_id                     = (known after apply)
      + connectivity_type                  = "public"
      + id                                 = (known after apply)
      + network_interface_id               = (known after apply)
      + private_ip                         = (known after apply)
      + public_ip                          = (known after apply)
      + secondary_private_ip_address_count = (known after apply)
      + secondary_private_ip_addresses     = (known after apply)
      + subnet_id                          = (known after apply)
      + tags                               = {
          + "Name" = "Main-NAT-Gateway"
        }
      + tags_all                           = {
          + "Name" = "Main-NAT-Gateway"
        }
    }

  # aws_network_acl.example will be created
  + resource "aws_network_acl" "example" {
      + arn        = (known after apply)
      + egress     = [
          + {
              + action          = "allow"
              + cidr_block      = "0.0.0.0/0"
              + from_port       = 0
              + protocol        = "-1"
              + rule_no         = 100
              + to_port         = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + id         = (known after apply)
      + ingress    = [
          + {
              + action          = "allow"
              + cidr_block      = "0.0.0.0/0"
              + from_port       = 0
              + protocol        = "-1"
              + rule_no         = 100
              + to_port         = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + owner_id   = (known after apply)
      + subnet_ids = (known after apply)
      + tags       = {
          + "Name" = "example-network-acl"
        }
      + tags_all   = {
          + "Name" = "example-network-acl"
        }
      + vpc_id     = (known after apply)
    }

  # aws_quicksight_dashboard.example will be created
  + resource "aws_quicksight_dashboard" "example" {
      + arn                 = (known after apply)
      + aws_account_id      = "654654500423"
      + created_time        = (known after apply)
      + dashboard_id        = "placeholder-dashboard"
      + id                  = (known after apply)
      + last_published_time = (known after apply)
      + last_updated_time   = (known after apply)
      + name                = "Placeholder Dashboard"
      + source_entity_arn   = (known after apply)
      + status              = (known after apply)
      + tags_all            = (known after apply)
      + version_description = "Dashboard version 1.0"
      + version_number      = (known after apply)

      + dashboard_publish_options (known after apply)

      + definition (known after apply)

      + parameters (known after apply)

      + source_entity {
          + source_template {
              + arn = "arn:aws:quicksight:eu-central-1:654654500423:template/placeholder-template-id"

              + data_set_references {
                  + data_set_arn         = "arn:aws:quicksight:eu-central-1:654654500423:dataset/example-dataset-id"
                  + data_set_placeholder = "example-placeholder"
                }
            }
        }
    }

  # aws_quicksight_group.example will be created
  + resource "aws_quicksight_group" "example" {
      + arn            = (known after apply)
      + aws_account_id = "654654500423"
      + group_name     = "example-group"
      + id             = (known after apply)
      + namespace      = "default"
    }

  # aws_redshift_cluster.example will be created
  + resource "aws_redshift_cluster" "example" {
      + allow_version_upgrade                = true
      + apply_immediately                    = false
      + aqua_configuration_status            = (known after apply)
      + arn                                  = (known after apply)
      + automated_snapshot_retention_period  = 1
      + availability_zone                    = (known after apply)
      + availability_zone_relocation_enabled = false
      + cluster_identifier                   = "example-cluster"
      + cluster_namespace_arn                = (known after apply)
      + cluster_nodes                        = (known after apply)
      + cluster_parameter_group_name         = (known after apply)
      + cluster_public_key                   = (known after apply)
      + cluster_revision_number              = (known after apply)
      + cluster_subnet_group_name            = (known after apply)
      + cluster_type                         = "single-node"
      + cluster_version                      = "1.0"
      + database_name                        = "exampledb"
      + default_iam_role_arn                 = (known after apply)
      + dns_name                             = (known after apply)
      + encrypted                            = false
      + endpoint                             = (known after apply)
      + enhanced_vpc_routing                 = (known after apply)
      + iam_roles                            = (known after apply)
      + id                                   = (known after apply)
      + kms_key_id                           = (known after apply)
      + maintenance_track_name               = "current"
      + manual_snapshot_retention_period     = -1
      + master_password                      = (sensitive value)
      + master_password_secret_arn           = (known after apply)
      + master_password_secret_kms_key_id    = (known after apply)
      + master_username                      = "admin"
      + multi_az                             = false
      + node_type                            = "dc2.large"
      + number_of_nodes                      = 1
      + port                                 = 5439
      + preferred_maintenance_window         = (known after apply)
      + publicly_accessible                  = true
      + skip_final_snapshot                  = true
      + tags                                 = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + tags_all                             = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + vpc_security_group_ids               = (known after apply)

      + logging (known after apply)

      + snapshot_copy (known after apply)
    }

  # aws_redshift_cluster.redshift_cluster will be created
  + resource "aws_redshift_cluster" "redshift_cluster" {
      + allow_version_upgrade                = true
      + apply_immediately                    = false
      + aqua_configuration_status            = (known after apply)
      + arn                                  = (known after apply)
      + automated_snapshot_retention_period  = 1
      + availability_zone                    = (known after apply)
      + availability_zone_relocation_enabled = false
      + cluster_identifier                   = (known after apply)
      + cluster_namespace_arn                = (known after apply)
      + cluster_nodes                        = (known after apply)
      + cluster_parameter_group_name         = (known after apply)
      + cluster_public_key                   = (known after apply)
      + cluster_revision_number              = (known after apply)
      + cluster_subnet_group_name            = (known after apply)
      + cluster_type                         = "multi-node"
      + cluster_version                      = "1.0"
      + database_name                        = (known after apply)
      + default_iam_role_arn                 = (known after apply)
      + dns_name                             = (known after apply)
      + encrypted                            = false
      + endpoint                             = (known after apply)
      + enhanced_vpc_routing                 = (known after apply)
      + iam_roles                            = (known after apply)
      + id                                   = (known after apply)
      + kms_key_id                           = (known after apply)
      + maintenance_track_name               = "current"
      + manual_snapshot_retention_period     = -1
      + master_password                      = (sensitive value)
      + master_password_secret_arn           = (known after apply)
      + master_password_secret_kms_key_id    = (known after apply)
      + master_username                      = "adminuser"
      + multi_az                             = false
      + node_type                            = "dc2.large"
      + number_of_nodes                      = 2
      + port                                 = 5439
      + preferred_maintenance_window         = (known after apply)
      + publicly_accessible                  = false
      + skip_final_snapshot                  = false
      + tags_all                             = (known after apply)
      + vpc_security_group_ids               = (known after apply)

      + logging (known after apply)

      + snapshot_copy (known after apply)
    }

  # aws_route_table.private will be created
  + resource "aws_route_table" "private" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + cidr_block                 = "0.0.0.0/0"
              + nat_gateway_id             = (known after apply)
                # (11 unchanged attributes hidden)
            },
        ]
      + tags             = {
          + "Name" = "Private-Route-Table"
        }
      + tags_all         = {
          + "Name" = "Private-Route-Table"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table.public will be created
  + resource "aws_route_table" "public" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + cidr_block                 = "0.0.0.0/0"
              + gateway_id                 = (known after apply)
                # (11 unchanged attributes hidden)
            },
        ]
      + tags             = {
          + "Name" = "Public-Route-Table"
        }
      + tags_all         = {
          + "Name" = "Public-Route-Table"
        }
      + vpc_id           = (known after apply)
    }

  # aws_route_table_association.private will be created
  + resource "aws_route_table_association" "private" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.public will be created
  + resource "aws_route_table_association" "public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_s3_bucket.backup_bucket will be created
  + resource "aws_s3_bucket" "backup_bucket" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = (known after apply)
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Name" = "Backup-Bucket"
        }
      + tags_all                    = {
          + "Name" = "Backup-Bucket"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.blob_storage will be created
  + resource "aws_s3_bucket" "blob_storage" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = (known after apply)
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = (known after apply)
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.cloudtrail_bucket will be created
  + resource "aws_s3_bucket" "cloudtrail_bucket" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "my-s3-bucket-name-cloudtrail"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Name" = "CloudTrail Bucket"
        }
      + tags_all                    = {
          + "Name" = "CloudTrail Bucket"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.data_lake will be created
  + resource "aws_s3_bucket" "data_lake" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = (known after apply)
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = (known after apply)
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.glacier_bucket will be created
  + resource "aws_s3_bucket" "glacier_bucket" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "my-s3-bucket-name-glacier"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Name" = "Glacier Bucket"
        }
      + tags_all                    = {
          + "Name" = "Glacier Bucket"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.scripts will be created
  + resource "aws_s3_bucket" "scripts" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = (known after apply)
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = (known after apply)
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.storage will be created
  + resource "aws_s3_bucket" "storage" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = (known after apply)
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + tags_all                    = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.temp will be created
  + resource "aws_s3_bucket" "temp" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = (known after apply)
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = (known after apply)
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket_lifecycle_configuration.storage_lifecycle will be created
  + resource "aws_s3_bucket_lifecycle_configuration" "storage_lifecycle" {
      + bucket                                 = (known after apply)
      + id                                     = (known after apply)
      + transition_default_minimum_object_size = (known after apply)

      + rule {
          + id     = "lifecycle-rule"
          + status = "Enabled"

          + expiration {
              + days                         = 30
              + expired_object_delete_marker = (known after apply)
            }
        }
    }

  # aws_s3_bucket_policy.storage_policy will be created
  + resource "aws_s3_bucket_policy" "storage_policy" {
      + bucket = (known after apply)
      + id     = (known after apply)
      + policy = (known after apply)
    }

  # aws_s3_bucket_server_side_encryption_configuration.storage_encryption will be created
  + resource "aws_s3_bucket_server_side_encryption_configuration" "storage_encryption" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + apply_server_side_encryption_by_default {
              + sse_algorithm     = "AES256"
                # (1 unchanged attribute hidden)
            }
        }
    }

  # aws_s3_bucket_versioning.backup_bucket_versioning will be created
  + resource "aws_s3_bucket_versioning" "backup_bucket_versioning" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

  # aws_s3_bucket_versioning.storage_versioning will be created
  + resource "aws_s3_bucket_versioning" "storage_versioning" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

  # aws_s3_object.data_blob will be created
  + resource "aws_s3_object" "data_blob" {
      + acl                    = "private"
      + arn                    = (known after apply)
      + bucket                 = (known after apply)
      + bucket_key_enabled     = (known after apply)
      + checksum_crc32         = (known after apply)
      + checksum_crc32c        = (known after apply)
      + checksum_sha1          = (known after apply)
      + checksum_sha256        = (known after apply)
      + content                = "Hello, this is a test file!"
      + content_type           = (known after apply)
      + etag                   = (known after apply)
      + force_destroy          = false
      + id                     = (known after apply)
      + key                    = "data-container/data-blob"
      + kms_key_id             = (known after apply)
      + server_side_encryption = (known after apply)
      + storage_class          = (known after apply)
      + tags_all               = (known after apply)
      + version_id             = (known after apply)
    }

  # aws_s3_object.data_container will be created
  + resource "aws_s3_object" "data_container" {
      + acl                    = (known after apply)
      + arn                    = (known after apply)
      + bucket                 = (known after apply)
      + bucket_key_enabled     = (known after apply)
      + checksum_crc32         = (known after apply)
      + checksum_crc32c        = (known after apply)
      + checksum_sha1          = (known after apply)
      + checksum_sha256        = (known after apply)
      + content_type           = (known after apply)
      + etag                   = (known after apply)
      + force_destroy          = false
      + id                     = (known after apply)
      + key                    = "data-container/"
      + kms_key_id             = (known after apply)
      + server_side_encryption = (known after apply)
      + storage_class          = (known after apply)
      + tags_all               = (known after apply)
      + version_id             = (known after apply)
    }

  # aws_s3_object.data_lake_filesystem will be created
  + resource "aws_s3_object" "data_lake_filesystem" {
      + acl                    = (known after apply)
      + arn                    = (known after apply)
      + bucket                 = (known after apply)
      + bucket_key_enabled     = (known after apply)
      + checksum_crc32         = (known after apply)
      + checksum_crc32c        = (known after apply)
      + checksum_sha1          = (known after apply)
      + checksum_sha256        = (known after apply)
      + content_type           = (known after apply)
      + etag                   = (known after apply)
      + force_destroy          = false
      + id                     = (known after apply)
      + key                    = "datalake-filesystem/"
      + kms_key_id             = (known after apply)
      + server_side_encryption = (known after apply)
      + storage_class          = (known after apply)
      + tags_all               = (known after apply)
      + version_id             = (known after apply)
    }

  # aws_s3_object.example_blob will be created
  + resource "aws_s3_object" "example_blob" {
      + acl                    = "private"
      + arn                    = (known after apply)
      + bucket                 = (known after apply)
      + bucket_key_enabled     = (known after apply)
      + checksum_crc32         = (known after apply)
      + checksum_crc32c        = (known after apply)
      + checksum_sha1          = (known after apply)
      + checksum_sha256        = (known after apply)
      + content_type           = (known after apply)
      + etag                   = (known after apply)
      + force_destroy          = false
      + id                     = (known after apply)
      + key                    = "example-folder/example-file.csv"
      + kms_key_id             = (known after apply)
      + server_side_encryption = (known after apply)
      + source                 = "path/to/local/example-file.csv"
      + storage_class          = (known after apply)
      + tags_all               = (known after apply)
      + version_id             = (known after apply)
    }

  # aws_secretsmanager_secret.example_secret will be created
  + resource "aws_secretsmanager_secret" "example_secret" {
      + arn                            = (known after apply)
      + description                    = "Example password secret"
      + force_overwrite_replica_secret = false
      + id                             = (known after apply)
      + kms_key_id                     = (known after apply)
      + name                           = "example-password"
      + name_prefix                    = (known after apply)
      + policy                         = (known after apply)
      + recovery_window_in_days        = 7
      + tags                           = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + tags_all                       = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }

      + replica (known after apply)
    }

  # aws_secretsmanager_secret.synapse_sql_password will be created
  + resource "aws_secretsmanager_secret" "synapse_sql_password" {
      + arn                            = (known after apply)
      + description                    = "Synapse SQL Password Secret"
      + force_overwrite_replica_secret = false
      + id                             = (known after apply)
      + kms_key_id                     = (known after apply)
      + name                           = "synapse-sql-password"
      + name_prefix                    = (known after apply)
      + policy                         = (known after apply)
      + recovery_window_in_days        = 7
      + tags                           = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }
      + tags_all                       = {
          + "Environment" = "dev"
          + "Project"     = "AWSDataInfraProject"
        }

      + replica (known after apply)
    }

  # aws_secretsmanager_secret_version.example_secret_value will be created
  + resource "aws_secretsmanager_secret_version" "example_secret_value" {
      + arn            = (known after apply)
      + id             = (known after apply)
      + secret_id      = (known after apply)
      + secret_string  = (sensitive value)
      + version_id     = (known after apply)
      + version_stages = (known after apply)
    }

  # aws_secretsmanager_secret_version.synapse_sql_password_value will be created
  + resource "aws_secretsmanager_secret_version" "synapse_sql_password_value" {
      + arn            = (known after apply)
      + id             = (known after apply)
      + secret_id      = (known after apply)
      + secret_string  = (sensitive value)
      + version_id     = (known after apply)
      + version_stages = (known after apply)
    }

  # aws_security_group.private_sg will be created
  + resource "aws_security_group" "private_sg" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = []
              + from_port        = 22
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = (known after apply)
              + self             = false
              + to_port          = 22
                # (1 unchanged attribute hidden)
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "Private-Security-Group"
        }
      + tags_all               = {
          + "Name" = "Private-Security-Group"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_security_group.public_sg will be created
  + resource "aws_security_group" "public_sg" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
                # (1 unchanged attribute hidden)
            },
        ]
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + from_port        = 22
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 22
                # (1 unchanged attribute hidden)
            },
        ]
      + name                   = (known after apply)
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "Public-Security-Group"
        }
      + tags_all               = {
          + "Name" = "Public-Security-Group"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_sns_topic.example will be created
  + resource "aws_sns_topic" "example" {
      + arn                         = (known after apply)
      + beginning_archive_time      = (known after apply)
      + content_based_deduplication = false
      + fifo_topic                  = false
      + id                          = (known after apply)
      + name                        = "example-topic"
      + name_prefix                 = (known after apply)
      + owner                       = (known after apply)
      + policy                      = (known after apply)
      + signature_version           = (known after apply)
      + tags_all                    = (known after apply)
      + tracing_config              = (known after apply)
    }

  # aws_subnet.main will be created
  + resource "aws_subnet" "main" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "us-east-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.1.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags_all                                       = (known after apply)
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.private will be created
  + resource "aws_subnet" "private" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "eu-central-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.2.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = false
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name" = "Private-Subnet"
        }
      + tags_all                                       = {
          + "Name" = "Private-Subnet"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_subnet.public will be created
  + resource "aws_subnet" "public" {
      + arn                                            = (known after apply)
      + assign_ipv6_address_on_creation                = false
      + availability_zone                              = "eu-central-1a"
      + availability_zone_id                           = (known after apply)
      + cidr_block                                     = "10.0.1.0/24"
      + enable_dns64                                   = false
      + enable_resource_name_dns_a_record_on_launch    = false
      + enable_resource_name_dns_aaaa_record_on_launch = false
      + id                                             = (known after apply)
      + ipv6_cidr_block_association_id                 = (known after apply)
      + ipv6_native                                    = false
      + map_public_ip_on_launch                        = true
      + owner_id                                       = (known after apply)
      + private_dns_hostname_type_on_launch            = (known after apply)
      + tags                                           = {
          + "Name" = "Public-Subnet"
        }
      + tags_all                                       = {
          + "Name" = "Public-Subnet"
        }
      + vpc_id                                         = (known after apply)
    }

  # aws_vpc.main will be created
  + resource "aws_vpc" "main" {
      + arn                                  = (known after apply)
      + cidr_block                           = "10.0.0.0/16"
      + default_network_acl_id               = (known after apply)
      + default_route_table_id               = (known after apply)
      + default_security_group_id            = (known after apply)
      + dhcp_options_id                      = (known after apply)
      + enable_dns_hostnames                 = true
      + enable_dns_support                   = true
      + enable_network_address_usage_metrics = (known after apply)
      + id                                   = (known after apply)
      + instance_tenancy                     = "default"
      + ipv6_association_id                  = (known after apply)
      + ipv6_cidr_block                      = (known after apply)
      + ipv6_cidr_block_network_border_group = (known after apply)
      + main_route_table_id                  = (known after apply)
      + owner_id                             = (known after apply)
      + tags                                 = {
          + "Name" = "Main-VPC"
        }
      + tags_all                             = {
          + "Name" = "Main-VPC"
        }
    }

  # random_id.unique_suffix will be created
  + resource "random_id" "unique_suffix" {
      + b64_std     = (known after apply)
      + b64_url     = (known after apply)
      + byte_length = 4
      + dec         = (known after apply)
      + hex         = (known after apply)
      + id          = (known after apply)
    }

  # random_string.bucket_suffix will be created
  + resource "random_string" "bucket_suffix" {
      + id          = (known after apply)
      + length      = 8
      + lower       = true
      + min_lower   = 0
      + min_numeric = 0
      + min_special = 0
      + min_upper   = 0
      + number      = true
      + numeric     = true
      + result      = (known after apply)
      + special     = false
      + upper       = true
    }

  # random_string.suffix_analytics will be created
  + resource "random_string" "suffix_analytics" {
      + id          = (known after apply)
      + length      = 6
      + lower       = true
      + min_lower   = 0
      + min_numeric = 0
      + min_special = 0
      + min_upper   = 0
      + number      = true
      + numeric     = true
      + result      = (known after apply)
      + special     = false
      + upper       = false
    }

  # random_string.suffix_processing will be created
  + resource "random_string" "suffix_processing" {
      + id          = (known after apply)
      + length      = 6
      + lower       = true
      + min_lower   = 0
      + min_numeric = 0
      + min_special = 0
      + min_upper   = 0
      + number      = true
      + numeric     = true
      + result      = (known after apply)
      + special     = false
      + upper       = false
    }

  # random_string.unique will be created
  + resource "random_string" "unique" {
      + id          = (known after apply)
      + length      = 8
      + lower       = true
      + min_lower   = 0
      + min_numeric = 0
      + min_special = 0
      + min_upper   = 0
      + number      = true
      + numeric     = true
      + result      = (known after apply)
      + special     = false
      + upper       = false
    }

Plan: 94 to add, 0 to change, 0 to destroy.
